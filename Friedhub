-- FF2 FULL SCRIPT WITH LOW GRAPHICS TOGGLE AND MORE
-- Features: Magnet, Pull Vector, Ball ESP, Landing Prediction, Trail, Auto Catch, Auto Rush, Long Arms, Low Graphics toggle

-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local Workspace = workspace

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- CONFIG
local config = {
    MagnetEnabled = true,
    MagnetRange = 60,
    MagnetStrength = 1,
    PullVectorEnabled = true,
    PullVectorStrength = 40,
    BallESPEnabled = true,
    LandingPredictionEnabled = true,
    UseTrail = true,
    AutoCatch = true,
    AutoRush = false,
    RushDistance = 30,
    RushCooldown = 1.2,
    ArmLength = 20,
    LowGraphicsEnabled = false,
    PredictionColor = Color3.fromRGB(255, 125, 0),
    ESPColor = Color3.fromRGB(0, 255, 125),
    MagnetTargetName = "Football",
}

-- Store original lighting settings for low graphics toggle revert
local originalLighting = {
    GlobalShadows = Lighting.GlobalShadows,
    Brightness = Lighting.Brightness,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    FogEnd = Lighting.FogEnd,
}

local function enableLowGraphics()
    Lighting.GlobalShadows = false
    Lighting.Brightness = 1
    Lighting.OutdoorAmbient = Color3.new(0.2, 0.2, 0.2)
    Lighting.FogEnd = 1e6
end

local function disableLowGraphics()
    Lighting.GlobalShadows = originalLighting.GlobalShadows
    Lighting.Brightness = originalLighting.Brightness
    Lighting.OutdoorAmbient = originalLighting.OutdoorAmbient
    Lighting.FogEnd = originalLighting.FogEnd
end

local lastRush = 0
local espObjects = {}
local predictionCache = {}

-- LONG ARMS FUNCTION
local voidChar = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local function applyLongArms()
    if voidChar then
        local l = voidChar:FindFirstChild("Left Arm") or voidChar:FindFirstChild("LeftUpperArm")
        local r = voidChar:FindFirstChild("Right Arm") or voidChar:FindFirstChild("RightUpperArm")
        if l and r and l:IsA("BasePart") and r:IsA("BasePart") then
            l.Size = Vector3.new(1, config.ArmLength, 1)
            r.Size = Vector3.new(1, config.ArmLength, 1)
        end
    end
end
LocalPlayer.CharacterAdded:Connect(function(c)
    voidChar = c
end)
RunService.Heartbeat:Connect(function()
    applyLongArms()
end)

-- UTILS
local function safeDestroy(obj)
    if obj and obj.Destroy then
        pcall(function() obj:Destroy() end)
    end
end

-- TRAJECTORY HELPERS
local Gravity = Vector3.new(0, -28, 0)
local SegmentCount = 160
local TimeStep = 0.035

local function getTrajectory(startPos, velocity)
    local pos, vel = startPos, velocity
    local points = {pos}
    for _ = 1, SegmentCount do
        vel += Gravity * TimeStep
        pos += vel * TimeStep
        table.insert(points, pos)
        if pos.Y < 0 then break end
    end
    return points, pos
end

local function makeArc(points, color)
    local atts, beams = {}, {}
    for _, p in ipairs(points) do
        local a = Instance.new("Attachment")
        a.WorldPosition = p
        a.Parent = Workspace.Terrain
        table.insert(atts, a)
    end
    for i = 1, #atts - 1 do
        local b = Instance.new("Beam")
        b.Attachment0 = atts[i]
        b.Attachment1 = atts[i + 1]
        b.Width0 = 0.6
        b.Width1 = 0.6
        b.Color = ColorSequence.new(color)
        b.Transparency = NumberSequence.new(0.05)
        b.LightEmission = 0.7
        b.Segments = 2
        b.FaceCamera = true
        b.Parent = Workspace.Terrain
        table.insert(beams, b)
    end
    return beams, atts
end

local function glowLoop(beams)
    task.spawn(function()
        local info = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
        for _, b in ipairs(beams) do
            TweenService:Create(b, info, {LightEmission = 2}):Play()
        end
        while beams[1] and beams[1].Parent do
            task.wait()
        end
    end)
end

local function ringMarker(pos, color)
    local ring = Instance.new("Part")
    ring.Anchored = true
    ring.CanCollide = false
    ring.Transparency = 1
    ring.Size = Vector3.new(1, 0.1, 1)
    ring.Position = pos + Vector3.new(0, 0.1, 0)
    ring.Material = Enum.Material.Neon
    ring.Color = color
    ring.Name = "FF2_LandingRing"
    ring.Parent = Workspace.Terrain

    local mesh = Instance.new("SpecialMesh", ring)
    mesh.MeshType = Enum.MeshType.Cylinder
    mesh.Scale = Vector3.new(0.1, 0.05, 0.1)

    TweenService:Create(mesh, TweenInfo.new(1), {Scale = Vector3.new(8, 0.05, 8)}):Play()
    TweenService:Create(ring, TweenInfo.new(1), {Transparency = 1}):Play()
    task.delay(1, function() safeDestroy(ring) end)
end

local function addTrail(part)
    if not part or not part:IsA("BasePart") then return end
    local a0 = Instance.new("Attachment", part)
    local a1 = Instance.new("Attachment")
    a1.Parent = Workspace.Terrain
    local beam = Instance.new("Beam")
    beam.Attachment0 = a0
    beam.Attachment1 = a1
    beam.Width0 = 0.35
    beam.Width1 = 0
    beam.LightEmission = 1
    beam.LightInfluence = 0
    beam.Segments = 2
    beam.Color = ColorSequence.new(Color3.fromRGB(255, 125, 0))
    beam.Transparency = NumberSequence.new(0, 1)
    beam.FaceCamera = true
    beam.Parent = part

    local con
    con = RunService.Heartbeat:Connect(function()
        if part and part.Parent == Workspace and part:IsA("BasePart") then
            if part.Velocity.Magnitude > 0 then
                a1.WorldPosition = part.Position - (part.Velocity.Magnitude > 0 and part.Velocity.Unit or Vector3.new()) * 2
            end
        else
            safeDestroy(beam)
            safeDestroy(a0)
            safeDestroy(a1)
            if con then con:Disconnect() end
        end
    end)
end

local function fadeOutBeams(beams, duration)
    task.spawn(function()
        local steps = 20
        for step = 1, steps do
            local t = step / steps
            for _, b in ipairs(beams) do
                b.Transparency = NumberSequence.new(t)
            end
            task.wait(duration / steps)
        end
        for _, b in ipairs(beams) do
            b.Transparency = NumberSequence.new(1)
        end
    end)
end

-- BALL ESP
local function createESP(ball)
    if espObjects[ball] then return end
    local adorn = Instance.new("BillboardGui")
    adorn.Adornee = ball
    adorn.AlwaysOnTop = true
    adorn.Size = UDim2.new(0, 100, 0, 30)
    adorn.StudsOffset = Vector3.new(0, 2, 0)
    adorn.Name = "FF2_BallESP_Gui"
    local label = Instance.new("TextLabel", adorn)
    label.Size = UDim2.fromScale(1, 1)
    label.BackgroundTransparency = 1
    label.TextScaled = true
    label.Font = Enum.Font.Code
    label.Text = "Ball"
    label.TextColor3 = config.ESPColor
    label.TextStrokeTransparency = 0.5
    label.RichText = false
    adorn.Parent = PlayerGui

    espObjects[ball] = {gui = adorn, connection = nil}
    espObjects[ball].connection = ball.AncestryChanged:Connect(function(_, parent)
        if not parent then
            if espObjects[ball] then
                safeDestroy(espObjects[ball].gui)
                if espObjects[ball].connection then espObjects[ball].connection:Disconnect() end
                espObjects[ball] = nil
            end
        end
    end)
end

local function updateESPVisibility()
    for _, data in pairs(espObjects) do
        data.gui.Enabled = config.BallESPEnabled
    end
end

-- MAGNET
local function applyMagnet(ball)
    if not config.MagnetEnabled then return end
    if not ball or not ball:IsA("BasePart") then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local distance = (ball.Position - hrp.Position).Magnitude
    if distance > config.MagnetRange then return end
    local direction = (hrp.Position - ball.Position).Unit
    local force = math.clamp(config.MagnetStrength * 500, 0, 1000) -- increased for OP magnet
    local currentY = ball.AssemblyLinearVelocity.Y * 0.3
    ball.AssemblyLinearVelocity = direction * force + Vector3.new(0, currentY, 0)
end

-- PULL VECTOR
local function applyPullVector(ball)
    if not config.PullVectorEnabled then return end
    if not ball or not ball:IsA("BasePart") then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local toBall = ball.Position - hrp.Position
    local influence = toBall.Unit * config.PullVectorStrength * 0.1
    ball.AssemblyLinearVelocity = ball.AssemblyLinearVelocity + influence
end

-- AUTO CATCH
local function tryAutoCatch()
    if not config.AutoCatch then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = LocalPlayer.Character.HumanoidRootPart
    for _, obj in pairs(Workspace:GetChildren()) do
        if obj.Name == config.MagnetTargetName and obj:IsA("BasePart") then
            local dist = (obj.Position - hrp.Position).Magnitude
            if dist <= config.MagnetRange then
                applyMagnet(obj)
            end
        end
    end
end

-- AUTO RUSH
local function tryAutoRush()
    if not config.AutoRush then return end
    if tick() - lastRush < config.RushCooldown then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = LocalPlayer.Character.HumanoidRootPart
    for _, obj in pairs(Workspace:GetChildren()) do
        if obj.Name == "Football" and obj:IsA("BasePart") then
            local dist = (obj.Position - hrp.Position).Magnitude
            if dist <= config.RushDistance then
                local look = hrp.CFrame.LookVector
                hrp.Velocity = look * 60
                lastRush = tick()
                break
            end
        end
    end
end

-- PREDICTION HANDLER
local function handleFootballPrediction(ball)
    if not ball or not ball:IsA("BasePart") then return end
    if predictionCache[ball] then return end
    predictionCache[ball] = true

    if not config.LandingPredictionEnabled then
        predictionCache[ball] = nil
        return
    end

    local velocity = ball.AssemblyLinearVelocity
    local points, landing = getTrajectory(ball.Position, velocity)
    local beams, atts = makeArc(points, config.PredictionColor)
    glowLoop(beams)
    ringMarker(landing, config.PredictionColor)
    if config.UseTrail then
        addTrail(ball)
    end

    local con
    con = RunService.Heartbeat:Connect(function()
        if not ball or not ball.Parent then
            fadeOutBeams(beams, 0.6)
            for _, a in ipairs(atts) do safeDestroy(a) end
            if con then con:Disconnect() end
            predictionCache[ball] = nil
            return
        end
        if ball.Velocity.Magnitude < 1 then
            if config.LandingPredictionEnabled then
                fadeOutBeams(beams, 0.8)
            else
                for _, b in ipairs(beams) do
                    b.Transparency = NumberSequence.new(1)
                end
            end
            for _, a in ipairs(atts) do safeDestroy(a) end
            if con then con:Disconnect() end
            predictionCache[ball] = nil
        end
    end)
end

-- WORLD MONITOR
workspace.ChildAdded:Connect(function(child)
    if child.Name == "Football" and child:IsA("BasePart") then
        task.wait()
        if config.BallESPEnabled then createESP(child) end
        if config.LandingPredictionEnabled then handleFootballPrediction(child) end
    end
end)

for _, obj in pairs(Workspace:GetChildren()) do
    if obj.Name == "Football" and obj:IsA("BasePart") then
        if config.BallESPEnabled then createESP(obj) end
        if config.LandingPredictionEnabled then handleFootballPrediction(obj) end
    end
end

-- MAIN LOOP
task.spawn(function()
    while true do
        tryAutoCatch()
        tryAutoRush()
        for _, obj in pairs(Workspace:GetChildren()) do
            if obj.Name == "Football" and obj:IsA("BasePart") then
                if config.MagnetEnabled then applyMagnet(obj) end
                if config.PullVectorEnabled then applyPullVector(obj) end
                if config.BallESPEnabled then createESP(obj) end
                if config.LandingPredictionEnabled then handleFootballPrediction(obj) end
            end
        end
        updateESPVisibility()
        RunService.Heartbeat:Wait()
    end
end)

-- GUI HELPERS
local function createToggle(parent, name, initial, callback)
    local container = Instance.new("Frame", parent)
    container.Size = UDim2.new(1, -12, 0, 24)
    container.BackgroundTransparency = 1

    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(0.58, 0, 1, 0)
    label.Position = UDim2.new(0, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = name
    label.Font = Enum.Font.Code
    label.TextSize = 14
    label.TextColor3 = Color3.new(1,1,1)
    label.TextXAlignment = Enum.TextXAlignment.Left

    local button = Instance.new("TextButton", container)
    button.Size = UDim2.new(0.35, 0, 1, 0)
    button.Position = UDim2.new(0.65, 0, 0, 0)
    button.Text = initial and "ON" or "OFF"
    button.Font = Enum.Font.Code
    button.TextSize = 14
    button.AutoButtonColor = false
    button.BackgroundColor3 = initial and Color3.fromRGB(50,150,50) or Color3.fromRGB(150,50,50)
    button.TextColor3 = Color3.new(1,1,1)
    local state = initial
    button.MouseButton1Click:Connect(function()
        state = not state
        button.Text = state and "ON" or "OFF"
        button.BackgroundColor3 = state and Color3.fromRGB(50,150,50) or Color3.fromRGB(150,50,50)
        callback(state)
    end)
    return container
end

local function createSlider(parent, name, min, max, initial, callback)
    local container = Instance.new("Frame", parent)
    container.Size = UDim2.new(1, -12, 0, 34)
    container.BackgroundTransparency = 1

    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(1, 0, 0, 16)
    label.BackgroundTransparency = 1
    label.Text = name .. ": " .. tostring(initial)
    label.Font = Enum.Font.Code
    label.TextSize = 13
    label.TextColor3 = Color3.new(1,1,1)
    label.TextXAlignment = Enum.TextXAlignment.Left

    local bar = Instance.new("Frame", container)
    bar.Size = UDim2.new(1, 0, 0, 14)
    bar.Position = UDim2.new(0, 0, 0, 18)
    bar.BackgroundColor3 = Color3.fromRGB(45,45,45)
    bar.BorderSizePixel = 0

    local fill = Instance.new("Frame", bar)
    fill.Size = UDim2.new((initial - min)/(max - min), 0, 1, 0)
    fill.BackgroundColor3 = Color3.fromRGB(100,100,100)
    fill.BorderSizePixel = 0

    local dragging = false
    bar.InputBegan:Connect(function(input)
