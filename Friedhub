-- Part 1: GUI + Settings + Magnet Modes (Legit, Blatant, League, Semi-Stealth)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()

local SETTINGS_KEY = "FriedHub_FF2_Settings"

-- Default settings
local settings = {
    magnetEnabled = true,
    magnetMode = "Legit", -- Legit, Blatant, League, Semi-Stealth
    autoCatch = true,
    magnetRange = 50,
    jumpBoost = 10,
}

-- Load settings
pcall(function()
    if readfile and isfile and isfile(SETTINGS_KEY) then
        local loaded = HttpService:JSONDecode(readfile(SETTINGS_KEY))
        for k,v in pairs(loaded) do settings[k] = v end
    end
end)

local function saveSettings()
    pcall(function()
        if writefile then
            writefile(SETTINGS_KEY, HttpService:JSONEncode(settings))
        end
    end)
end

-- GUI Setup
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "FriedHub_FF2"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game.CoreGui

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 400, 0, 460)
mainFrame.Position = UDim2.new(0.5, -200, 0.5, -230)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = ScreenGui

local uicorner = Instance.new("UICorner", mainFrame)
uicorner.CornerRadius = UDim.new(0, 8)

local title = Instance.new("TextLabel", mainFrame)
title.Size = UDim2.new(1, 0, 0, 40)
title.BackgroundTransparency = 1
title.Font = Enum.Font.GothamBold
title.TextSize = 22
title.TextColor3 = Color3.fromRGB(255, 140, 0)
title.Text = "FriedHub FF2 Ultimate"
title.TextStrokeTransparency = 0.6
title.TextXAlignment = Enum.TextXAlignment.Left
title.Position = UDim2.new(0, 15, 0, 0)

-- Tabs Frame
local tabsFrame = Instance.new("Frame", mainFrame)
tabsFrame.Size = UDim2.new(0, 110, 1, -40)
tabsFrame.Position = UDim2.new(0, 0, 0, 40)
tabsFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
tabsFrame.BorderSizePixel = 0
local tabsUICorner = Instance.new("UICorner", tabsFrame)
tabsUICorner.CornerRadius = UDim.new(0, 8)

-- Pages Frame
local pagesFrame = Instance.new("Frame", mainFrame)
pagesFrame.Size = UDim2.new(1, -110, 1, -40)
pagesFrame.Position = UDim2.new(0, 110, 0, 40)
pagesFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
pagesFrame.BorderSizePixel = 0
local pagesUICorner = Instance.new("UICorner", pagesFrame)
pagesUICorner.CornerRadius = UDim.new(0, 8)

-- Tabs and Pages
local tabNames = {"Magnet"}
local tabs = {}
local pages = {}
local selectedTab = nil

local function selectTab(name)
    for tabName, btn in pairs(tabs) do
        btn.BackgroundColor3 = (tabName == name) and Color3.fromRGB(255, 140, 0) or Color3.fromRGB(30, 30, 30)
        btn.TextColor3 = (tabName == name) and Color3.new(1,1,1) or Color3.fromRGB(180,180,180)
    end
    for pageName, page in pairs(pages) do
        page.Visible = (pageName == name)
    end
    selectedTab = name
end

for i, tabName in ipairs(tabNames) do
    local btn = Instance.new("TextButton", tabsFrame)
    btn.Size = UDim2.new(1, 0, 0, 40)
    btn.Position = UDim2.new(0, 0, 0, (i-1)*40)
    btn.BackgroundColor3 = Color3.fromRGB(30,30,30)
    btn.Font = Enum.Font.GothamSemibold
    btn.TextSize = 16
    btn.Text = tabName
    btn.TextColor3 = Color3.fromRGB(180,180,180)
    btn.BorderSizePixel = 0

    btn.MouseButton1Click:Connect(function()
        selectTab(tabName)
    end)

    tabs[tabName] = btn

    local page = Instance.new("ScrollingFrame", pagesFrame)
    page.Size = UDim2.new(1, 0, 1, 0)
    page.Position = UDim2.new(0, 0, 0, 0)
    page.BackgroundTransparency = 1
    page.ScrollBarThickness = 6
    page.Visible = false
    page.CanvasSize = UDim2.new(0, 0, 0, 0)
    pages[tabName] = page
end

selectTab(tabNames[1])

-- Utility functions to create toggles and dropdowns
local function createToggle(parent, text, initial, callback)
    local btn = Instance.new("TextButton", parent)
    btn.Size = UDim2.new(1, -20, 0, 30)
    btn.Position = UDim2.new(0, 10, 0, (#parent:GetChildren())*35)
    btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.AutoButtonColor = false

    local enabled = initial
    btn.Text = text .. ": " .. (enabled and "ON" or "OFF")

    btn.MouseButton1Click:Connect(function()
        enabled = not enabled
        btn.Text = text .. ": " .. (enabled and "ON" or "OFF")
        callback(enabled)
        saveSettings()
    end)
    return btn
end

local function createDropdown(parent, text, options, initialIndex, callback)
    local dropdown = Instance.new("TextButton", parent)
    dropdown.Size = UDim2.new(1, -20, 0, 30)
    dropdown.Position = UDim2.new(0, 10, 0, (#parent:GetChildren())*35)
    dropdown.BackgroundColor3 = Color3.fromRGB(30,30,30)
    dropdown.TextColor3 = Color3.new(1,1,1)
    dropdown.Font = Enum.Font.Gotham
    dropdown.TextSize = 14

    local selectedIndex = initialIndex or 1
    dropdown.Text = text .. ": " .. options[selectedIndex]

    dropdown.MouseButton1Click:Connect(function()
        selectedIndex = selectedIndex + 1
        if selectedIndex > #options then selectedIndex = 1 end
        dropdown.Text = text .. ": " .. options[selectedIndex]
        callback(options[selectedIndex])
        saveSettings()
    end)
    return dropdown
end

local function createSlider(parent, text, initial, min, max, callback)
    local frame = Instance.new("Frame", parent)
    frame.Size = UDim2.new(1, -20, 0, 40)
    frame.Position = UDim2.new(0, 10, 0, (#parent:GetChildren())*40)

    local label = Instance.new("TextLabel", frame)
    label.Size = UDim2.new(1, 0, 0, 18)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.new(1,1,1)
    label.Font = Enum.Font.Gotham
    label.TextSize = 14
    label.Text = text .. ": " .. tostring(initial)
    label.TextXAlignment = Enum.TextXAlignment.Left

    local slider = Instance.new("TextBox", frame)
    slider.Size = UDim2.new(1, 0, 0, 18)
    slider.Position = UDim2.new(0, 0, 0, 20)
    slider.BackgroundColor3 = Color3.fromRGB(40,40,40)
    slider.TextColor3 = Color3.new(1,1,1)
    slider.Font = Enum.Font.Gotham
    slider.TextSize = 14
    slider.Text = tostring(initial)
    slider.ClearTextOnFocus = true

    slider.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            local val = tonumber(slider.Text)
            if val then
                val = math.clamp(val, min, max)
                slider.Text = tostring(val)
                label.Text = text .. ": " .. val
                callback(val)
                saveSettings()
            else
                slider.Text = tostring(initial)
            end
        else
            slider.Text = tostring(initial)
        end
    end)
    return frame
end

-- Magnet Toggles and Settings on Magnet Tab
createToggle(pages["Magnet"], "Enable Magnet", settings.magnetEnabled, function(v) settings.magnetEnabled = v end)

local magnetModes = {"Legit", "Blatant", "League", "Semi-Stealth"}
local initialModeIndex = table.find(magnetModes, settings.magnetMode) or 1
createDropdown(pages["Magnet"], "Magnet Mode", magnetModes, initialModeIndex, function(v) settings.magnetMode = v end)

createToggle(pages["Magnet"], "Auto Catch", settings.autoCatch, function(v) settings.autoCatch = v end)
createSlider(pages["Magnet"], "Magnet Range", settings.magnetRange, 10, 80, function(v) settings.magnetRange = v end)
createSlider(pages["Magnet"], "Jump Boost", settings.jumpBoost, 0, 25, function(v) settings.jumpBoost = v end)

-- Magnet Logic
local lastCatch = 0
local catchCooldown = 0.25

local function getBall()
    return workspace:FindFirstChild("Football")
end

local function getCatchPositions(char)
    local left = char:FindFirstChild("CatchLeft")
    local right = char:FindFirstChild("CatchRight")
    if left and right then
        return left.Position, right.Position
    end
    return nil, nil
end

local function isFacingTarget(hrpCFrame, targetPos)
    local lookVector = hrpCFrame.LookVector
    local dir = (targetPos - hrpCFrame.Position).Unit
    return lookVector:Dot(dir) > 0.5
end

-- Semi-Stealth Magnet (from your code)
local function semiStealthMagnet()
    local lpChar = player.Character
    if not lpChar then return end
    local left = lpChar:FindFirstChild("CatchLeft")
    local right = lpChar:FindFirstChild("CatchRight")
    if not (left and right) then return end

    local mid = left.Position:Lerp(right.Position, 0.5)
    local ball = workspace:FindFirstChild("Football") or workspace:FindFirstChildWhichIsA("Tool")
    if not ball or not ball:IsDescendantOf(workspace) then return end

    local dist = (ball.Position - mid).Magnitude
    if dist <= 28 then -- semi-stealth range
        local target = mid + Vector3.new(0, -1.1, -0.8)
        ball.CFrame = CFrame.new(target)
        ball.Velocity = Vector3.zero
    end
end

-- Main Magnet Heartbeat Loop
RunService.Heartbeat:Connect(function()
    if not settings.magnetEnabled then return end

    local ball = getBall()
    local char = player.Character
    if not ball or not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local now = tick()
    if now - lastCatch < catchCooldown then return end

    if settings.magnetMode == "Semi-Stealth" then
        semiStealthMagnet()
        lastCatch = now
        return
    end

    local catchLeftPos, catchRightPos = getCatchPositions(char)
    if not (catchLeftPos and catchRightPos) then return end

    local predictedPos = ball.Position + (ball.AssemblyLinearVelocity * 0.15)
    local distPredicted = (predictedPos - hrp.Position).Magnitude

    if distPredicted > settings.magnetRange then return end

    local facing = isFacingTarget(hrp.CFrame, ball.Position)

    if settings.magnetMode == "Legit" and facing then
        -- Pull ball smoothly to one catch position or the other, closer side
        local targetPos = (predictedPos - catchLeftPos).Magnitude < (predictedPos - catchRightPos).Magnitude and catchLeftPos or catchRightPos
        local bv = ball:FindFirstChild("FriedHubMagnetBodyVelocity")
        if not bv then
            bv = Instance.new("BodyVelocity")
            bv.Name = "FriedHubMagnetBodyVelocity"
            bv.MaxForce = Vector3.new(1e5,1e5,1e5)
            bv.Parent = ball
        end
        bv.Velocity = (targetPos - ball.Position) * 30
        lastCatch = now
    elseif settings.magnetMode == "Blatant" then
        -- Teleport ball directly to catch center
        ball.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 3, 0))
        lastCatch = now
    elseif settings.magnetMode == "League" then
        -- Pull ball using BodyVelocity but faster than Legit
        local targetPos = hrp.Position + Vector3.new(0, 3, 0)
        local bv = ball:FindFirstChild("FriedHubMagnetBodyVelocity")
        if not bv then
            bv = Instance.new("BodyVelocity")
            bv.Name = "FriedHubMagnetBodyVelocity"
            bv.MaxForce = Vector3.new(1e6,1e6,1e6)
            bv.Parent = ball
        end
        bv.Velocity = (targetPos - ball.Position) * 60
        lastCatch = now
    end
end)

print("[FriedHub] Part 1 loaded.")-- Part 2: Ball ESP + Ball Path Prediction + Jump Boost + Anti-Jam

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

-- Settings (should sync with Part 1 if needed)
local jumpBoostAmount = 10
local jumpCooldown = 2 -- seconds between boosts
local lastJumpTime = 0

local ballESPEnabled = true -- could be toggled from GUI later
local ballPathPredictionEnabled = true -- could be toggled from GUI later

-- Ball ESP Setup
local ballHighlight = nil
local function setupBallESP(ball)
    if ballHighlight then
        ballHighlight.Adornee = ball
        return
    end

    local Highlight = Instance.new("Highlight")
    Highlight.Name = "FriedHubBallHighlight"
    Highlight.Adornee = ball
    Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    Highlight.FillColor = Color3.fromRGB(255, 125, 0)
    Highlight.FillTransparency = 0.3
    Highlight.OutlineColor = Color3.fromRGB(255, 125, 0)
    Highlight.OutlineTransparency = 0
    Highlight.Parent = ball
    ballHighlight = Highlight
end

local function removeBallESP()
    if ballHighlight then
        ballHighlight:Destroy()
        ballHighlight = nil
    end
end

-- Ball Path Prediction Variables
local Gravity = Vector3.new(0, -28, 0)
local SegmentCount = 160
local TimeStep = 0.035

local beams = {}
local attachments = {}

local function clearBeams()
    for _, beam in ipairs(beams) do
        beam:Destroy()
    end
    for _, att in ipairs(attachments) do
        att:Destroy()
    end
    beams = {}
    attachments = {}
end

local function getTrajectory(startPos, velocity)
    local pos, vel = startPos, velocity
    local points = {pos}
    for _ = 1, SegmentCount do
        vel = vel + Gravity * TimeStep
        pos = pos + vel * TimeStep
        table.insert(points, pos)
        if pos.Y < 0 then
            break
        end
    end
    return points, pos
end

local function makeArc(points, color)
    clearBeams()
    local newAtts, newBeams = {}, {}
    for _, p in ipairs(points) do
        local a = Instance.new("Attachment")
        a.WorldPosition = p
        a.Parent = workspace.Terrain
        table.insert(newAtts, a)
    end
    for i = 1, #newAtts - 1 do
        local b = Instance.new("Beam")
        b.Attachment0 = newAtts[i]
        b.Attachment1 = newAtts[i + 1]
        b.Width0 = 0.85
        b.Width1 = 0.85
        b.Color = ColorSequence.new(color)
        b.Transparency = NumberSequence.new(0.02)
        b.LightEmission = 0.5
        b.Segments = 2
        b.FaceCamera = true
        b.Parent = workspace.Terrain
        table.insert(newBeams, b)
    end
    beams = newBeams
    attachments = newAtts
    return beams, attachments
end

local function ringMarker(pos, color)
    local ring = Instance.new("Part")
    ring.Anchored = true
    ring.CanCollide = false
    ring.Transparency = 1
    ring.Size = Vector3.new(1, 0.1, 1)
    ring.Position = pos + Vector3.new(0, 0.1, 0)
    ring.Material = Enum.Material.Neon
    ring.Color = color
    ring.Parent = workspace.Terrain

    local mesh = Instance.new("SpecialMesh", ring)
    mesh.MeshType = Enum.MeshType.Cylinder
    mesh.Scale = Vector3.new(0.1, 0.05, 0.1)

    TweenService:Create(mesh, TweenInfo.new(1), {Scale = Vector3.new(8, 0.05, 8)}):Play()
    TweenService:Create(ring, TweenInfo.new(1), {Transparency = 1}):Play()
    task.delay(1, function() ring:Destroy() end)
end

local function addTrail(part)
    local a0 = Instance.new("Attachment", part)
    local a1 = Instance.new("Attachment")
    a1.Parent = workspace.Terrain
    local beam = Instance.new("Beam")
    beam.Attachment0 = a0
    beam.Attachment1 = a1
    beam.Width0 = 0.4
    beam.Width1 = 0
    beam.LightEmission = 1
    beam.LightInfluence = 0
    beam.Segments = 2
    beam.Color = ColorSequence.new(Color3.fromRGB(255, 125, 0))
    beam.Transparency = NumberSequence.new(0, 1)
    beam.FaceCamera = true
    beam.Parent = part

    local con
    con = RunService.Heartbeat:Connect(function()
        if part and part.Parent == workspace then
            a1.WorldPosition = part.Position - part.Velocity.Unit * 2
        else
            beam:Destroy()
            a0:Destroy()
            a1:Destroy()
            con:Disconnect()
        end
    end)
end

local function fadeOutBeams(duration)
    task.spawn(function()
        local steps = 30
        for step = 1, steps do
            local t = step / steps
            for _, b in ipairs(beams) do
                b.Transparency = NumberSequence.new(t)
            end
            task.wait(duration / steps)
        end
        for _, b in ipairs(beams) do
            b.Transparency = NumberSequence.new(1)
        end
        clearBeams()
    end)
end

-- Jump Boost + Anti-Jam logic
local function applyJumpBoost()
    local now = tick()
    if now - lastJumpTime < jumpCooldown then
        return
    end

    if humanoid and humanoid.FloorMaterial ~= Enum.Material.Air then
        humanoid.JumpPower = humanoid.JumpPower + jumpBoostAmount
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        -- Reset jump power smoothly after 0.5 seconds
        task.delay(0.5, function()
            if humanoid then
                humanoid.JumpPower = 50 -- default jump power, adjust if your game uses different
            end
        end)
        lastJumpTime = now
    end
end

-- Monitor ball and apply effects
local ball = workspace:FindFirstChild("Football")

workspace.ChildAdded:Connect(function(child)
    if child.Name == "Football" and child:IsA("BasePart") then
        ball = child

        if ballESPEnabled then
            setupBallESP(ball)
        end

        -- Path prediction arc and effects
        task.spawn(function()
            while ball and ball.Parent == workspace do
                RunService.Heartbeat:Wait()
                local velocity = ball.AssemblyLinearVelocity
                if ballPathPredictionEnabled then
                    local points, landing = getTrajectory(ball.Position, velocity)
                    makeArc(points, Color3.fromRGB(255, 125, 0))
                    ringMarker(landing, Color3.fromRGB(255, 125, 0))
                    addTrail(ball)
                end

                -- Jump Boost: when ball close to player within range 10 studs, boost jump once
                if (ball.Position - hrp.Position).Magnitude < 10 then
                    applyJumpBoost()
                end
            end
            fadeOutBeams(1)
            removeBallESP()
        end)
    end
end)

-- Also monitor if ball already exists on script start
if ball then
    setupBallESP(ball)
end

print("[FriedHub] Part 2 loaded.")-- Part 3: Long Arms, Auto Catch, Auto Rush, Low Graphics

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

local settings = {
    longArms = false,
    autoCatch = false,
    autoRush = false,
    lowGraphics = false,
}

-- Long Arms Implementation
local function setLongArms(state)
    local char = player.Character
    if not char then return end
    for _, limbName in pairs({"Left Arm", "Right Arm"}) do
        local limb = char:FindFirstChild(limbName)
        if limb and limb:IsA("BasePart") then
            if state then
                limb.Size = Vector3.new(2, 5, 2)
            else
                limb.Size = Vector3.new(2, 2, 1)
            end
        end
    end
end

-- Auto Catch Implementation
local function getBall()
    return workspace:FindFirstChild("Football")
end

local catchCooldown = 0.2
local lastCatch = 0

local function tryAutoCatch()
    local ball = getBall()
    local char = player.Character
    if not ball or not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local now = tick()
    if now - lastCatch < catchCooldown then return end

    local dist = (ball.Position - hrp.Position).Magnitude
    if dist < 10 then
        local catchLeft = char:FindFirstChild("CatchLeft")
        local catchRight = char:FindFirstChild("CatchRight")
        if catchLeft and catchRight then
            -- Move ball to closest catch position instantly (semi-stealth catch)
            local leftDist = (ball.Position - catchLeft.Position).Magnitude
            local rightDist = (ball.Position - catchRight.Position).Magnitude
            local targetPos = (leftDist < rightDist) and catchLeft.Position or catchRight.Position
            ball.CFrame = CFrame.new(targetPos)
            ball.Velocity = Vector3.zero
            lastCatch = now
        end
    end
end

-- Auto Rush Implementation
local autoRushSpeed = 20
local autoRushConnection = nil

local function setAutoRush(state)
    if state then
        if autoRushConnection then return end
        autoRushConnection = RunService.Heartbeat:Connect(function()
            local char = player.Character
            if char then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Velocity = Vector3.new(0, hrp.Velocity.Y, autoRushSpeed)
                end
            end
        end)
    else
        if autoRushConnection then
            autoRushConnection:Disconnect()
            autoRushConnection = nil
        end
    end
end

-- Low Graphics Implementation
local function setLowGraphics(state)
    if state then
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.Material = Enum.Material.SmoothPlastic
                obj.Reflectance = 0
            elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                obj.Enabled = false
            end
        end
        game.Lighting.GlobalShadows = false
    else
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.Material = Enum.Material.Plastic
            elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                obj.Enabled = true
            end
        end
        game.Lighting.GlobalShadows = true
    end
end

-- Run a loop to handle auto catch continuously
RunService.Heartbeat:Connect(function()
    if settings.autoCatch then
        tryAutoCatch()
    end
end)

-- Example of GUI toggle callbacks (to be connected to your GUI later)
local function onLongArmsToggle(value)
    settings.longArms = value
    setLongArms(value)
end

local function onAutoCatchToggle(value)
    settings.autoCatch = value
end

local function onAutoRushToggle(value)
    settings.autoRush = value
    setAutoRush(value)
end

local function onLowGraphicsToggle(value)
    settings.lowGraphics = value
    setLowGraphics(value)
end

-- Initial setup calls if needed
if settings.longArms then setLongArms(true) end
if settings.autoRush then setAutoRush(true) end
if settings.lowGraphics then setLowGraphics(true) end

print("[FriedHub] Part 3 loaded.")-- Part 4: Freeze Tech, Magnet Modes, Enhanced Angle Enhancer (with jump boost), Misc

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

local settings = {
    freezeTech = false,
    freezeTime = 2,
    magnetEnabled = true,
    magnetMode = "Legit", -- "Legit", "Blatant", "League", "Semi-Stealth"
    angleEnhancer = true,
    jumpBoostOnCatch = true,
    jumpBoostAmount = 10,
}

-- Freeze Tech Implementation
local freezeConnection = nil
local function freezeCharacter(duration)
    if freezeConnection then
        freezeConnection:Disconnect()
        freezeConnection = nil
    end

    local originalWalkSpeed = humanoid.WalkSpeed
    local originalJumpPower = humanoid.JumpPower

    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0

    freezeConnection = RunService.Heartbeat:Connect(function()
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0
        hrp.Velocity = Vector3.new(0,0,0)
        hrp.RotVelocity = Vector3.new(0,0,0)
    end)

    task.delay(duration, function()
        if freezeConnection then
            freezeConnection:Disconnect()
            freezeConnection = nil
        end
        humanoid.WalkSpeed = originalWalkSpeed
        humanoid.JumpPower = originalJumpPower
    end)
end

-- Magnet Modes

local function getCatchPositions()
    local catchLeft = character:FindFirstChild("CatchLeft")
    local catchRight = character:FindFirstChild("CatchRight")
    return catchLeft, catchRight
end

local magRange = 50

local function semiStealthMagnet(ball)
    local catchLeft, catchRight = getCatchPositions()
    if not catchLeft or not catchRight then return end

    local mid = catchLeft.Position:Lerp(catchRight.Position, 0.5)
    local dist = (ball.Position - mid).Magnitude
    if dist <= 28 then
        local target = mid + Vector3.new(0, -1.1, -0.8)
        ball.CFrame = CFrame.new(target)
        ball.Velocity = Vector3.zero
    end
end

local function blatantMagnet(ball)
    local catchLeft, catchRight = getCatchPositions()
    if not catchLeft or not catchRight then return end

    local targetPos = catchLeft.Position:Lerp(catchRight.Position, 0.5)
    local bv = ball:FindFirstChild("FriedHubMagnetBodyVelocity")
    if not bv then
        bv = Instance.new("BodyVelocity")
        bv.Name = "FriedHubMagnetBodyVelocity"
        bv.MaxForce = Vector3.new(1e5, 1e5, 1e5)
        bv.Parent = ball
    end
    bv.Velocity = (targetPos - ball.Position) * 50
end

local function legitMagnet(ball)
    local catchLeft, catchRight = getCatchPositions()
    if not catchLeft or not catchRight then return end

    local targetPos = catchLeft.Position:Lerp(catchRight.Position, 0.5)
    local bv = ball:FindFirstChild("FriedHubMagnetBodyVelocity")
    if not bv then
        bv = Instance.new("BodyVelocity")
        bv.Name = "FriedHubMagnetBodyVelocity"
        bv.MaxForce = Vector3.new(1e4, 1e4, 1e4)
        bv.Parent = ball
    end
    bv.Velocity = (targetPos - ball.Position) * 20
end

local function leagueMagnet(ball)
    local catchLeft, catchRight = getCatchPositions()
    if not catchLeft or not catchRight then return end

    local targetPos = catchLeft.Position:Lerp(catchRight.Position, 0.5)
    ball.CFrame = CFrame.new(targetPos)
    ball.Velocity = Vector3.zero
end

-- Enhanced Angle Enhancer + Jump Boost

local lastJumpBoostTime = 0
local jumpBoostCooldown = 1 -- seconds between boosts

local function enhanceAngleAndJump(ball)
    if not settings.angleEnhancer then return end
    if not ball then return end
    local char = character
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    -- Face the ball smoothly
    local toBall = (ball.Position - hrp.Position).Unit
    local lookVector = hrp.CFrame.LookVector
    local dot = lookVector:Dot(toBall)
    if dot < 0.7 then
        local newCFrame = CFrame.new(hrp.Position, ball.Position)
        hrp.CFrame = hrp.CFrame:Lerp(newCFrame, 0.2)
    end

    -- Jump boost logic when ball close
    if settings.jumpBoostOnCatch then
        local catchLeft, catchRight = getCatchPositions()
        if catchLeft and catchRight then
            local mid = catchLeft.Position:Lerp(catchRight.Position, 0.5)
            local dist = (ball.Position - mid).Magnitude
            local now = tick()

            if dist < 10 and (now - lastJumpBoostTime) > jumpBoostCooldown then
                if humanoid.FloorMaterial ~= Enum.Material.Air then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    humanoid.JumpPower = (humanoid.JumpPower or 50) + settings.jumpBoostAmount
                    lastJumpBoostTime = now
                    -- Reset JumpPower to default after short delay
                    task.delay(0.5, function()
                        if humanoid then
                            humanoid.JumpPower = 50
                        end
                    end)
                end
            end
        end
    end
end

-- Magnet Loop
RunService.Heartbeat:Connect(function()
    if not settings.magnetEnabled then return end
    local ball = workspace:FindFirstChild("Football")
    if not ball then return end
    local dist = (ball.Position - hrp.Position).Magnitude
    if dist > magRange then
        local bv = ball:FindFirstChild("FriedHubMagnetBodyVelocity")
        if bv then bv:Destroy() end
        return
    end

    enhanceAngleAndJump(ball)

    if settings.magnetMode == "Semi-Stealth" then
        semiStealthMagnet(ball)
    elseif settings.magnetMode == "Blatant" then
        blatantMagnet(ball)
    elseif settings.magnetMode == "Legit" then
        legitMagnet(ball)
    elseif settings.magnetMode == "League" then
        leagueMagnet(ball)
    end
end)

-- Example GUI callbacks:

local function onFreezeTechToggle(state)
    settings.freezeTech = state
    if state then
        freezeCharacter(settings.freezeTime)
    end
end

local function onFreezeTimeChange(val)
    settings.freezeTime = val
end

local function onMagnetEnabledToggle(state)
    settings.magnetEnabled = state
end

local function onMagnetModeChange(mode)
    settings.magnetMode = mode
end

local function onAngleEnhancerToggle(state)
    settings.angleEnhancer = state
end

local function onJumpBoostToggle(state)
    settings.jumpBoostOnCatch = state
end

local function onJumpBoostAmountChange(val)
    settings.jumpBoostAmount = val
end

print("[FriedHub] Part 4 loaded with enhanced angle enhancer and jump boost.")
