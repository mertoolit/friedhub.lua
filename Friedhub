-- FriedHub V2 - Part 1 (Core GUI, Main & Mags Tabs, Semi Magnet)

-- Services
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UIS = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local CoreGui = game:GetService("CoreGui")

-- Cleanup old GUI
local oldGui = CoreGui:FindFirstChild("FriedHub")
if oldGui then oldGui:Destroy() end

-- Helper: UICorner creator
local function createUICorner(parent)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 10)
    corner.Parent = parent
    return corner
end

-- Helper: Create button
local function createButton(text, size, pos, parent)
    local btn = Instance.new("TextButton")
    btn.Text = text
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 16
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    btn.Size = size
    btn.Position = pos
    createUICorner(btn)
    btn.Parent = parent
    return btn
end

-- Helper: Create label
local function createLabel(text, size, pos, parent)
    local lbl = Instance.new("TextLabel")
    lbl.Text = text
    lbl.Font = Enum.Font.GothamSemibold
    lbl.TextSize = 18
    lbl.TextColor3 = Color3.fromRGB(255, 140, 0)
    lbl.BackgroundTransparency = 1
    lbl.Size = size
    lbl.Position = pos
    lbl.Parent = parent
    return lbl
end

-- Helper: Create toggle button
local function createToggle(text, parent, yPos, callback)
    local toggle = Instance.new("TextButton")
    toggle.Size = UDim2.new(0, 230, 0, 35)
    toggle.Position = UDim2.new(0, 10, 0, yPos)
    toggle.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
    toggle.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggle.Font = Enum.Font.Gotham
    toggle.TextSize = 15
    toggle.Text = "[ OFF ] " .. text
    createUICorner(toggle)
    toggle.Parent = parent

    local state = false
    toggle.MouseButton1Click:Connect(function()
        state = not state
        toggle.Text = (state and "[ ON ] " or "[ OFF ] ") .. text
        pcall(callback, state)
    end)
    return toggle
end

-- Helper: Create slider with label
local function createSlider(labelText, min, max, default, yPos, parent, callback)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 250, 0, 50)
    frame.Position = UDim2.new(0, 10, 0, yPos)
    frame.BackgroundTransparency = 1
    frame.Parent = parent

    local label = Instance.new("TextLabel")
    label.Text = labelText .. ": " .. tostring(default)
    label.Font = Enum.Font.Gotham
    label.TextSize = 14
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.BackgroundTransparency = 1
    label.Position = UDim2.new(0, 0, 0, 0)
    label.Size = UDim2.new(1, 0, 0, 20)
    label.Parent = frame

    local sliderBar = Instance.new("Frame")
    sliderBar.Size = UDim2.new(1, -10, 0, 12)
    sliderBar.Position = UDim2.new(0, 5, 0, 30)
    sliderBar.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    createUICorner(sliderBar)
    sliderBar.Parent = frame

    local sliderHandle = Instance.new("Frame")
    sliderHandle.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)
    sliderHandle.BackgroundColor3 = Color3.fromRGB(255, 140, 0)
    createUICorner(sliderHandle)
    sliderHandle.Parent = sliderBar

    local dragging = false
    sliderHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
        end
    end)
    sliderHandle.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    UIS.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local relativePos = math.clamp((input.Position.X - sliderBar.AbsolutePosition.X) / sliderBar.AbsoluteSize.X, 0, 1)
            sliderHandle.Size = UDim2.new(relativePos, 0, 1, 0)
            local value = math.floor(min + (max - min) * relativePos)
            label.Text = labelText .. ": " .. tostring(value)
            pcall(callback, value)
        end
    end)

    return frame
end

-- Create main GUI frame
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "FriedHub"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = CoreGui

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 540, 0, 390)
MainFrame.Position = UDim2.new(0.3, 0, 0.25, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.Draggable = true
MainFrame.Parent = ScreenGui
createUICorner(MainFrame)

local TitleLabel = createLabel("ðŸŸ§ FriedHub V2", UDim2.new(1, 0, 0, 40), UDim2.new(0, 0, 0, 5), MainFrame)

-- Open/Close buttons
local CloseBtn = createButton("âœ–", UDim2.new(0, 35, 0, 35), UDim2.new(1, -40, 0, 5), MainFrame)
CloseBtn.BackgroundColor3 = Color3.fromRGB(80, 0, 0)

local OpenBtn = createButton("âš™ï¸", UDim2.new(0, 45, 0, 45), UDim2.new(0.02, 0, 0.85, 0), ScreenGui)
OpenBtn.BackgroundColor3 = Color3.fromRGB(255, 130, 0)
OpenBtn.Visible = false

CloseBtn.MouseButton1Click:Connect(function()
    MainFrame.Visible = false
    OpenBtn.Visible = true
end)
OpenBtn.MouseButton1Click:Connect(function()
    MainFrame.Visible = true
    OpenBtn.Visible = false
end)

-- Tabs Setup
local TabNames = {"Main", "Mags", "Visuals", "Misc"}
local TabButtons = {}
local TabPages = {}

for i, name in ipairs(TabNames) do
    local btn = createButton(name, UDim2.new(0, 120, 0, 30), UDim2.new(0, 15 + (i - 1) * 130, 0, 50), MainFrame)
    btn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    btn.TextColor3 = Color3.fromRGB(255, 160, 50)
    TabButtons[name] = btn

    local page = Instance.new("ScrollingFrame")
    page.Name = name .. "Page"
    page.Size = UDim2.new(1, -30, 1, -110)
    page.Position = UDim2.new(0, 15, 0, 90)
    page.BackgroundTransparency = 1
    page.ScrollBarThickness = 6
    page.Visible = (i == 1)
    page.Parent = MainFrame
    TabPages[name] = page

    btn.MouseButton1Click:Connect(function()
        for _, p in pairs(TabPages) do p.Visible = false end
        page.Visible = true
    end)
end

-- === Global State ===
local State = {
    MagnetActive = false,
    MagnetModes = {"Off", "Legit", "Blatant", "League"},
    MagnetIndex = 1,
    JumpPower = 50,
    WalkSpeed = 23,
    FreezeTech = 0,
    AngleEnhancer = 0,
    BallESP = false,
    BallPath = false,
    LongArms = false,
}

local LocalHumanoid
local LocalRootPart

local function updateCharacterRefs()
    local char = LocalPlayer.Character
    if char then
        LocalHumanoid = char:FindFirstChildOfClass("Humanoid")
        LocalRootPart = char:FindFirstChild("HumanoidRootPart")
    end
end
updateCharacterRefs()
LocalPlayer.CharacterAdded:Connect(updateCharacterRefs)

-- === MAIN TAB ===
local mainPage = TabPages["Main"]

-- Low Graphics Toggle
createToggle("Low Graphics Mode", mainPage, 10, function(enabled)
    local lighting = game:GetService("Lighting")
    if enabled then
        lighting.Brightness = 0
        lighting.GlobalShadows = false
        lighting.FogEnd = 1e8
        lighting.OutdoorAmbient = Color3.new(0, 0, 0)
        for _, part in pairs(Workspace:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Material = Enum.Material.SmoothPlastic
                part.Reflectance = 0
            end
        end
    else
        lighting.Brightness = 2
        lighting.GlobalShadows = true
        lighting.FogEnd = 1e8
        lighting.OutdoorAmbient = Color3.new(0.5, 0.5, 0.5)
    end
end)

-- Rejoin Button
local rejoinBtn = createButton("ðŸ”„ Rejoin Game", UDim2.new(0, 230, 0, 35), UDim2.new(0, 10, 0, 60), mainPage)
rejoinBtn.BackgroundColor3 = Color3.fromRGB(255, 140, 0)
rejoinBtn.TextColor3 = Color3.new(0, 0, 0)
rejoinBtn.MouseButton1Click:Connect(function()
    TeleportService:Teleport(game.PlaceId, LocalPlayer)
end)

-- === MAGS TAB ===
local magsPage = TabPages["Mags"]

-- Magnet Toggle Button
local magnetToggleBtn = createToggle("Magnet", magsPage, 10, function(enabled)
    State.MagnetActive = enabled
    if enabled then
        startMagnetLoop()
    else
        stopMagnetLoop()
    end
    updateMagnetToggleText()
end)

-- Magnet Mode Button
local magnetModeBtn = createButton("Mode: Off", UDim2.new(0, 230, 0, 35), UDim2.new(0, 10, 0, 60), magsPage)
magnetModeBtn.MouseButton1Click:Connect(function()
    State.MagnetIndex = State.MagnetIndex + 1
    if State.MagnetIndex > #State.MagnetModes then
        State.MagnetIndex = 1
    end
    magnetModeBtn.Text = "Mode: " .. State.MagnetModes[State.MagnetIndex]
    updateMagnetToggleText()
end)

local function updateMagnetToggleText()
    if State.MagnetActive then
        magnetToggleBtn.Text = "[ ON ] Magnet - " .. State.MagnetModes[State.MagnetIndex]
    else
        magnetToggleBtn.Text = "[ OFF ] Magnet"
    end
end
updateMagnetToggleText()

-- Jump Power Slider
createSlider("Jump Power", 25, 100, State.JumpPower, 110, magsPage, function(value)
    State.JumpPower = value
    if LocalHumanoid then
        LocalHumanoid.JumpPower = value
    end
end)

-- Walk Speed Slider
createSlider("Walk Speed", 16, 70, State.WalkSpeed, 170, magsPage, function(value)
    State.WalkSpeed = value
    if LocalHumanoid then
        LocalHumanoid.WalkSpeed = value
    end
end)

-- Freeze Tech Slider
createSlider("Freeze Tech", 0, 100, State.FreezeTech, 230, magsPage, function(value)
    State.FreezeTech = value
    -- freeze tech logic (placeholder)
    -- You can add freeze tech feature here
end)

-- Angle Enhancer Slider
createSlider("Angle Enhancer", 0, 100, State.AngleEnhancer, 290, magsPage, function(value)
    State.AngleEnhancer = value
    -- angle enhancer logic (placeholder)
    -- Add your angle enhancing feature here
end)

-- === SEMI-STEALTH MAGNET LOOP ===
local semiMagnetConn
local function startMagnetLoop()
    if semiMagnetConn then return end
    semiMagnetConn = RunService.Heartbeat:Connect(function()
        if not State.MagnetActive or State.MagnetModes[State.MagnetIndex] == "Off" then return end
        if not LocalRootPart or not LocalHumanoid or LocalHumanoid.Health <= 0 then return end

        local ball = Workspace:FindFirstChild("Football")
        if not ball then return end

        local dist = (ball.Position - LocalRootPart.Position).Magnitude
        if dist > 28 then return end

        local mode = State.MagnetModes[State.MagnetIndex]

        local catchLeft = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("CatchLeft")
        local catchRight = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("CatchRight")
        if not catchLeft or not catchRight then return end

        local targetPos
        if mode == "Legit" then
            local leftDist = (ball.Position - catchLeft.Position).Magnitude
            local rightDist = (ball.Position - catchRight.Position).Magnitude
            targetPos = (leftDist < rightDist) and catchLeft.Position or catchRight.Position
            ball.Velocity = (targetPos - ball.Position) * 50 -- smooth pull
        elseif mode == "Blatant" then
            targetPos = catchRight.Position
            ball.CFrame = CFrame.new(targetPos)
            ball.Velocity = Vector3.new(0, 0, 0)
        elseif mode == "League" then
            targetPos = catchLeft.Position + Vector3.new(0, 3, 0)
            ball.Velocity = (targetPos - ball.Position) * 45
        end
    end)
end

local function stopMagnetLoop()
    if semiMagnetConn then
        semiMagnetConn:Disconnect()
        semiMagnetConn = nil
    end
end

-- Finished Part 1; Part 2 with Visuals & Misc coming up next!-- FriedHub V2 - Part 2 (Visuals, Ball ESP & Path Prediction, Misc Tab)

-- Use same ScreenGui, TabPages, State, RunService from Part 1

local visualsPage = TabPages["Visuals"]
local miscPage = TabPages["Misc"]

-- Ball ESP toggle
local ballESPToggleBtn = createToggle("Ball ESP", visualsPage, 10, function(enabled)
    State.BallESP = enabled
    if enabled then
        enableBallESP()
    else
        disableBallESP()
    end
end)

local ESPHighlights = {}

local function createHighlight(part)
    local highlight = Instance.new("Highlight")
    highlight.Adornee = part
    highlight.FillColor = Color3.fromRGB(255, 165, 0)
    highlight.OutlineColor = Color3.fromRGB(255, 115, 0)
    highlight.Parent = part
    return highlight
end

function enableBallESP()
    local ball = Workspace:FindFirstChild("Football")
    if ball and not ESPHighlights[ball] then
        ESPHighlights[ball] = createHighlight(ball)
    end
end

function disableBallESP()
    for ball, highlight in pairs(ESPHighlights) do
        highlight:Destroy()
        ESPHighlights[ball] = nil
    end
end

-- Auto-manage highlights each frame
RunService.Heartbeat:Connect(function()
    if State.BallESP then
        local ball = Workspace:FindFirstChild("Football")
        if ball and not ESPHighlights[ball] then
            ESPHighlights[ball] = createHighlight(ball)
        elseif not ball and next(ESPHighlights) then
            disableBallESP()
        end
    end
end)

-- Ball Path Prediction toggle
local ballPathToggle = createToggle("Ball Path Prediction", visualsPage, 50, function(enabled)
    State.BallPath = enabled
    if enabled then
        startBallPathPrediction()
    else
        stopBallPathPrediction()
        clearBallPathVisual()
    end
end)

local ballPathParts = {}
local ballPathConnection

local function clearBallPathVisual()
    for _, part in pairs(ballPathParts) do
        part:Destroy()
    end
    ballPathParts = {}
end

local function startBallPathPrediction()
    if ballPathConnection then return end
    ballPathConnection = RunService.Heartbeat:Connect(function()
        clearBallPathVisual()
        local ball = Workspace:FindFirstChild("Football")
        if not ball then return end
        local ballVel = ball.Velocity
        local ballPos = ball.Position

        local gravity = Workspace.Gravity or 196.2
        local timeStep = 0.1
        local totalSteps = 20

        for i = 1, totalSteps do
            local t = i * timeStep
            local futurePos = ballPos
                + ballVel * t-- FriedHub V2 - Part 3 (Finish Ball Path Prediction + Misc Tab)

local visualsPage = TabPages["Visuals"]
local miscPage = TabPages["Misc"]

-- Continue Ball Path Prediction visuals from Part 2

local gravity = Workspace.Gravity or 196.2
local ballPathParts = ballPathParts or {}
local ballPathConnection = ballPathConnection or nil

local function createPathPart(position)
    local part = Instance.new("Part")
    part.Size = Vector3.new(0.3, 0.3, 0.3)
    part.Anchored = true
    part.CanCollide = false
    part.Material = Enum.Material.Neon
    part.Color = Color3.fromRGB(255, 140, 0)
    part.Position = position
    part.Parent = Workspace
    return part
end

function startBallPathPrediction()
    if ballPathConnection then return end
    ballPathConnection = RunService.Heartbeat:Connect(function()
        for _, part in pairs(ballPathParts) do
            part:Destroy()
        end
        ballPathParts = {}

        local ball = Workspace:FindFirstChild("Football")
        if not ball then return end
        local ballVel = ball.Velocity
        local ballPos = ball.Position

        local timeStep = 0.1
        local totalSteps = 20

        for i = 1, totalSteps do
            local t = i * timeStep
            local futurePos = ballPos
                + ballVel * t
                + Vector3.new(0, -0.5 * gravity * t * t, 0)
            local pathPart = createPathPart(futurePos)
            table.insert(ballPathParts, pathPart)
        end
    end)
end

function stopBallPathPrediction()
    if ballPathConnection then
        ballPathConnection:Disconnect()
        ballPathConnection = nil
    end
    for _, part in pairs(ballPathParts) do
        part:Destroy()
    end
    ballPathParts = {}
end

-- === MISC TAB ===
-- Rejoin Button
local rejoinBtnMisc = createButton("ðŸ”„ Rejoin Game", UDim2.new(0, 230, 0, 35), UDim2.new(0, 10, 0, 10), miscPage)
rejoinBtnMisc.BackgroundColor3 = Color3.fromRGB(255, 140, 0)
rejoinBtnMisc.TextColor3 = Color3.new(0, 0, 0)
rejoinBtnMisc.MouseButton1Click:Connect(function()
    TeleportService:Teleport(game.PlaceId, LocalPlayer)
end)

-- Long Arms Toggle
local longArmsToggle = createToggle("Long Arms", miscPage, 60, function(enabled)
    State.LongArms = enabled
    local char = LocalPlayer.Character
    if not char then return end

    -- Extend arms length or reset
    local function setLongArms(bool)
        for _, limbName in pairs({"LeftUpperArm", "RightUpperArm", "LeftLowerArm", "RightLowerArm"}) do
            local part = char:FindFirstChild(limbName)
            if part and part:IsA("BasePart") then
                if bool then
                    part.Size = Vector3.new(1, 3, 1) -- stretch lengthened arms
                else
                    part.Size = Vector3.new(1, 2, 1) -- reset normal arms
                end
            end
        end
    end

    setLongArms(enabled)
end)

-- Cleanup on character respawn for long arms reset
LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    if State.LongArms then
        local function setLongArmsOnSpawn()
            for _, limbName in pairs({"LeftUpperArm", "RightUpperArm", "LeftLowerArm", "RightLowerArm"}) do
                local part = char:FindFirstChild(limbName)
                if part and part:IsA("BasePart") then
                    part.Size = Vector3.new(1, 3, 1)
                end
            end
        end
        setLongArmsOnSpawn()
    end
end)

-- Final: Notify that FriedHub loaded
print("[FriedHub V2] Loaded successfully.")

--[[
INSTRUCTIONS:
- Execute Part 1 first
- Then execute Part 2
- Finally execute Part 3
All parts share same global GUI and state.
]]
                + Vector
