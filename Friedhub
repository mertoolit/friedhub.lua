-- FriedHub FF2 Part 1

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local SETTINGS_KEY = "FriedHub_FF2_Settings"

local settings = {
    magnetEnabled = true,
    magnetMode = "Semi-Stealth", -- Legit, Blatant, League, Semi-Stealth
    autoCatch = true,
    freezeTech = false,
    freezeTime = 2,
    freezeSlider = 2,
    esp = true,
    ballPath = true,
    lowGraphics = false,
    longArms = false,
    magnetRange = 28,
    angleEnhancer = true,
    angleSlider = 10,
    jumpBoost = true,
    jumpBoostAmount = 10,
}

-- Load saved settings
pcall(function()
    if readfile and isfile and isfile(SETTINGS_KEY) then
        local loaded = HttpService:JSONDecode(readfile(SETTINGS_KEY))
        for k,v in pairs(loaded) do settings[k] = v end
    end
end)

local function saveSettings()
    pcall(function()
        if writefile then
            writefile(SETTINGS_KEY, HttpService:JSONEncode(settings))
        end
    end)
end

-- GUI creation omitted here for brevity; assume standard tabs Magnet, Misc, ESP with toggles/sliders reflecting settings --

-- Magnet logic

local function getMid()
    local char = player.Character or player.CharacterAdded:Wait()
    local left = char:WaitForChild("CatchLeft")
    local right = char:WaitForChild("CatchRight")
    return left.Position:Lerp(right.Position, 0.5)
end

local magnetPart = nil

task.spawn(function()
    while true do
        if not settings.magnetEnabled then task.wait(0.1) continue end

        local ball = workspace:FindFirstChild("Football") or workspace:FindFirstChildWhichIsA("Tool")
        if ball and ball:IsDescendantOf(workspace) then
            local mid = getMid()
            local dist = (ball.Position - mid).Magnitude

            if dist <= settings.magnetRange then
                if settings.magnetMode == "Semi-Stealth" then
                    local target = mid + Vector3.new(0, -1.1, -0.8)
                    ball.CFrame = CFrame.new(target)
                    ball.Velocity = Vector3.zero
                else
                    -- Other magnet modes logic (Legit, Blatant, League)
                    -- For brevity, simple BodyVelocity implementation
                    if not ball:FindFirstChild("FriedHubMagnetBodyVelocity") then
                        local bv = Instance.new("BodyVelocity")
                        bv.Name = "FriedHubMagnetBodyVelocity"
                        bv.MaxForce = Vector3.new(1e5,1e5,1e5)
                        bv.Parent = ball
                    end
                    local bv = ball:FindFirstChild("FriedHubMagnetBodyVelocity")
                    local targetPos = mid
                    if settings.magnetMode == "Legit" then
                        targetPos = mid + Vector3.new(0, 1, 0)
                    elseif settings.magnetMode == "Blatant" then
                        targetPos = mid + Vector3.new(0, 3, 0)
                    elseif settings.magnetMode == "League" then
                        targetPos = mid + Vector3.new(0, 5, 0)
                    end
                    bv.Velocity = (targetPos - ball.Position).Unit * 70
                end
            else
                if ball:FindFirstChild("FriedHubMagnetBodyVelocity") then
                    ball.FriedHubMagnetBodyVelocity:Destroy()
                end
            end
        end
        task.wait(0.05)
    end
end)

-- Jump Boost on catch
local lastJump = 0
local jumpCooldown = 0.5

RunService.Heartbeat:Connect(function()
    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then return end

    local ball = workspace:FindFirstChild("Football")
    if not ball then return end

    local dist = (ball.Position - hrp.Position).Magnitude

    if dist < 5 and settings.jumpBoost then
        local now = tick()
        if now - lastJump > jumpCooldown then
            hum.JumpPower = hum.JumpPower + settings.jumpBoostAmount
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            lastJump = now
            task.delay(0.2, function()
                if hum then
                    hum.JumpPower = 50 -- reset to default (adjust if needed)
                end
            end)
        end
    end
end)

-- Freeze Tech slider logic
local freezing = false
local freezeStartTime = 0

RunService.Heartbeat:Connect(function()
    if settings.freezeTech and not freezing then
        freezing = true
        freezeStartTime = tick()

        local char = player.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.WalkSpeed = 0
                hum.JumpPower = 0
            end
        end
    elseif freezing then
        if tick() - freezeStartTime >= settings.freezeSlider then
            freezing = false
            local char = player.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    hum.WalkSpeed = 16
                    hum.JumpPower = 50
                end
            end
        end
    end
end)

-- Angle Enhancer slider logic (adds height on jump and dive)
local UserInputService = game:GetService("UserInputService")-- FriedHub FF2 Part 2 - Ball Path Prediction

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local Gravity = Vector3.new(0, -28, 0)
local SegmentCount = 160
local TimeStep = 0.035
local UseTrail = true

local function getTrajectory(startPos, velocity)
    local pos, vel = startPos, velocity
    local points = {pos}
    for _=1, SegmentCount do
        vel += Gravity * TimeStep
        pos += vel * TimeStep
        table.insert(points, pos)
        if pos.Y < 0 then break end
    end
    return points, pos
end

local function makeArc(points, color)
    local atts, beams = {}, {}
    for _, p in ipairs(points) do
        local a = Instance.new("Attachment")
        a.WorldPosition = p
        a.Parent = workspace.Terrain
        table.insert(atts, a)
    end
    for i=1, #atts-1 do
        local b = Instance.new("Beam")
        b.Attachment0 = atts[i]
        b.Attachment1 = atts[i+1]
        b.Width0 = 0.85
        b.Width1 = 0.85
        b.Color = ColorSequence.new(color)
        b.Transparency = NumberSequence.new(0.02)
        b.LightEmission = 0.5
        b.Segments = 2
        b.FaceCamera = true
        b.Parent = workspace.Terrain
        table.insert(beams, b)
    end
    return beams, atts
end

local function glowLoop(beams)
    task.spawn(function()
        local info = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
        for _, b in ipairs(beams) do
            TweenService:Create(b, info, {LightEmission = 2}):Play()
        end
        while beams[1] and beams[1].Parent do task.wait() end
    end)
end

local function ringMarker(pos, color)
    local ring = Instance.new("Part")
    ring.Anchored = true
    ring.CanCollide = false
    ring.Transparency = 1
    ring.Size = Vector3.new(1, 0.1, 1)
    ring.Position = pos + Vector3.new(0, 0.1, 0)
    ring.Material = Enum.Material.Neon
    ring.Color = color
    ring.Parent = workspace.Terrain

    local mesh = Instance.new("SpecialMesh", ring)
    mesh.MeshType = Enum.MeshType.Cylinder
    mesh.Scale = Vector3.new(0.1, 0.05, 0.1)

    TweenService:Create(mesh, TweenInfo.new(1), {Scale = Vector3.new(8, 0.05, 8)}):Play()
    TweenService:Create(ring, TweenInfo.new(1), {Transparency = 1}):Play()
    task.delay(1, function() ring:Destroy() end)
end

local function addTrail(part)
    local a0 = Instance.new("Attachment", part)
    local a1 = Instance.new("Attachment")
    a1.Parent = workspace.Terrain
    local beam = Instance.new("Beam")
    beam.Attachment0 = a0
    beam.Attachment1 = a1
    beam.Width0 = 0.4
    beam.Width1 = 0
    beam.LightEmission = 1
    beam.LightInfluence = 0
    beam.Segments = 2
    beam.Color = ColorSequence.new(Color3.fromRGB(255, 125, 0))
    beam.Transparency = NumberSequence.new(0,1)
    beam.FaceCamera = true
    beam.Parent = part

    local con
    con = RunService.Heartbeat:Connect(function()
        if part and part.Parent == workspace then
            a1.WorldPosition = part.Position - part.Velocity.Unit * 2
        else
            beam:Destroy()
            a0:Destroy()
            a1:Destroy()
            con:Disconnect()
        end
    end)
end

local function fadeOutBeams(beams, duration)
    task.spawn(function()
        local steps = 30
        for step=1, steps do
            local t = step/steps
            for _, b in ipairs(beams) do
                b.Transparency = NumberSequence.new(t)
            end
            task.wait(duration/steps)
        end
        for _, b in ipairs(beams) do
            b.Transparency = NumberSequence.new(1)
        end
    end)
end

workspace.ChildAdded:Connect(function(b)
    if b.Name == "Football" and b:IsA("BasePart") then
        task.wait()
        RunService.Heartbeat:Wait()
        local velocity = b.AssemblyLinearVelocity
        local color = Color3.fromRGB(255, 125, 0) -- Orange
        local points, landing = getTrajectory(b.Position, velocity)
        local beams, atts = makeArc(points, color)
        glowLoop(beams)
        ringMarker(landing, color)
        if UseTrail then addTrail(b) end

        local con
        con = RunService.Heartbeat:Connect(function()
            if b.Velocity.Magnitude < 1 then
                fadeOutBeams(beams, 1)
                for _, a in ipairs(atts) do a:Destroy() end
                con:Disconnect()
            end
        end)

        repeat task.wait() until b.Parent ~= workspace
        for _, beam in ipairs(beams) do beam.Transparency = NumberSequence.new(1) end
        for _, a in ipairs(atts) do a:Destroy() end
    end
end)-- FriedHub FF2 Part 3 - Anti Jam, Safe WalkSpeed, Misc

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hum = char:WaitForChild("Humanoid")

-- Anti Jam Variables
local lastBallPos = nil
local jamThreshold = 0.5
local jamCheckInterval = 1

-- WalkSpeed Control
local walkSpeedDefault = 16
local walkSpeedSafe = 20

local walkSpeedEnabled = true
local walkSpeedValue = walkSpeedSafe

task.spawn(function()
    while true do
        if walkSpeedEnabled and hum then
            hum.WalkSpeed = walkSpeedValue
        else
            hum.WalkSpeed = walkSpeedDefault
        end
        task.wait(0.5)
    end
end)

-- Anti Jam: Detect if ball stuck and reset position
task.spawn(function()
    while true do
        local ball = workspace:FindFirstChild("Football")
        if ball then
            if lastBallPos and (ball.Position - lastBallPos).Magnitude < jamThreshold then
                ball.Velocity = Vector3.new(0, 50, 0) -- "unstick" by giving upward velocity
            end
            lastBallPos = ball.Position
        end
        task.wait(jamCheckInterval)
    end
end)

-- Additional misc features like ESP toggles, low graphics toggles can be added similarly

UserInputService.JumpRequest:Connect(function()
    if settings.angleEnhancer then
        local char = player.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum and hum:GetState() == Enum.HumanoidStateType.Running then
                hum.JumpPower = 50 + settings.angleSlider
                hum:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end
end)

-- Save settings on change hooks (assumed to be hooked in GUI code)

-- Rest of GUI code omitted for brevity but includes toggles and sliders for all settings.
