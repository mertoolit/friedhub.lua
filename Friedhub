-- == FF2 HUB SCRIPT: Rayfield + Lua Hub + All Features Toggleable ==
-- Integrated per request. Draggable fallback GUI + Rayfield if present.

-- ====== SERVICES ======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local Workspace = workspace

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Mouse = LocalPlayer:GetMouse()

-- ====== CONFIG ======
local config = {
    MagnetEnabled = true,
    MagnetRange = 60,
    MagnetStrength = 1,
    PullVectorEnabled = true,
    PullVectorStrength = 40,
    BallESPEnabled = true,
    LandingPredictionEnabled = true,
    UseTrail = true,
    AutoCatch = true,
    AutoRush = false,
    RushDistance = 30,
    RushCooldown = 1.2,
    PredictionColor = Color3.fromRGB(255, 125, 0),
    ESPColor = Color3.fromRGB(0, 255, 125),
    MagnetTargetName = "Football",
}

-- ====== TRAJECTORY CONSTANTS ======
local Gravity = Vector3.new(0, -28, 0)
local SegmentCount = 160
local TimeStep = 0.035

-- ====== STATE ======
local lastRush = 0
local espObjects = {}
local predictionCache = {}

-- ====== UTIL ======
local function safeDestroy(obj)
    if obj and pcall(function() return obj.Destroy end) then
        pcall(function() obj:Destroy() end)
    end
end

-- ====== TRAJECTORY HELPERS ======
local function getTrajectory(startPos, velocity)
    local pos, vel = startPos, velocity
    local points = {pos}
    for _ = 1, SegmentCount do
        vel += Gravity * TimeStep
        pos += vel * TimeStep
        table.insert(points, pos)
        if pos.Y < 0 then break end
    end
    return points, pos
end

local function makeArc(points, color)
    local atts, beams = {}, {}
    for _, p in ipairs(points) do
        local a = Instance.new("Attachment")
        a.WorldPosition = p
        a.Parent = Workspace.Terrain
        table.insert(atts, a)
    end
    for i = 1, #atts - 1 do
        local b = Instance.new("Beam")
        b.Attachment0 = atts[i]
        b.Attachment1 = atts[i + 1]
        b.Width0 = 0.6
        b.Width1 = 0.6
        b.Color = ColorSequence.new(color)
        b.Transparency = NumberSequence.new(0.05)
        b.LightEmission = 0.7
        b.Segments = 2
        b.FaceCamera = true
        b.Parent = Workspace.Terrain
        table.insert(beams, b)
    end
    return beams, atts
end

local function glowLoop(beams)
    task.spawn(function()
        local info = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
        for _, b in ipairs(beams) do
            TweenService:Create(b, info, {LightEmission = 2}):Play()
        end
        while beams[1] and beams[1].Parent do
            task.wait()
        end
    end)
end

local function ringMarker(pos, color)
    local ring = Instance.new("Part")
    ring.Anchored = true
    ring.CanCollide = false
    ring.Transparency = 1
    ring.Size = Vector3.new(1, 0.1, 1)
    ring.Position = pos + Vector3.new(0, 0.1, 0)
    ring.Material = Enum.Material.Neon
    ring.Color = color
    ring.Name = "FF2_LandingRing"
    ring.Parent = Workspace.Terrain

    local mesh = Instance.new("SpecialMesh", ring)
    mesh.MeshType = Enum.MeshType.Cylinder
    mesh.Scale = Vector3.new(0.1, 0.05, 0.1)

    TweenService:Create(mesh, TweenInfo.new(1), {Scale = Vector3.new(8, 0.05, 8)}):Play()
    TweenService:Create(ring, TweenInfo.new(1), {Transparency = 1}):Play()
    task.delay(1, function() safeDestroy(ring) end)
end

local function addTrail(part)
    if not part or not part:IsA("BasePart") then return end
    local a0 = Instance.new("Attachment", part)
    local a1 = Instance.new("Attachment")
    a1.Parent = Workspace.Terrain
    local beam = Instance.new("Beam")
    beam.Attachment0 = a0
    beam.Attachment1 = a1
    beam.Width0 = 0.35
    beam.Width1 = 0
    beam.LightEmission = 1
    beam.LightInfluence = 0
    beam.Segments = 2
    beam.Color = ColorSequence.new(Color3.fromRGB(255, 125, 0))
    beam.Transparency = NumberSequence.new(0, 1)
    beam.FaceCamera = true
    beam.Parent = part

    local con
    con = RunService.Heartbeat:Connect(function()
        if part and part.Parent == Workspace and part:IsA("BasePart") then
            if part.Velocity.Magnitude > 0 then
                a1.WorldPosition = part.Position - (part.Velocity.Magnitude > 0 and part.Velocity.Unit or Vector3.new()) * 2
            end
        else
            safeDestroy(beam)
            safeDestroy(a0)
            safeDestroy(a1)
            if con then con:Disconnect() end
        end
    end)
end

local function fadeOutBeams(beams, duration)
    task.spawn(function()
        local steps = 20
        for step = 1, steps do
            local t = step / steps
            for _, b in ipairs(beams) do
                b.Transparency = NumberSequence.new(t)
            end
            task.wait(duration / steps)
        end
        for _, b in ipairs(beams) do
            b.Transparency = NumberSequence.new(1)
        end
    end)
end

-- ====== BALL ESP ======
local function createESP(ball)
    if espObjects[ball] then return end
    local adorn = Instance.new("BillboardGui")
    adorn.Adornee = ball
    adorn.AlwaysOnTop = true
    adorn.Size = UDim2.new(0, 100, 0, 30)
    adorn.StudsOffset = Vector3.new(0, 2, 0)
    adorn.Name = "FF2_BallESP_Gui"
    local label = Instance.new("TextLabel", adorn)
    label.Size = UDim2.fromScale(1, 1)
    label.BackgroundTransparency = 1
    label.TextScaled = true
    label.Font = Enum.Font.Code
    label.Text = "Ball"
    label.TextColor3 = config.ESPColor
    label.TextStrokeTransparency = 0.5
    label.RichText = false
    adorn.Parent = PlayerGui

    espObjects[ball] = {gui = adorn, connection = nil}
    espObjects[ball].connection = ball.AncestryChanged:Connect(function(_, parent)
        if not parent then
            if espObjects[ball] then
                safeDestroy(espObjects[ball].gui)
                if espObjects[ball].connection then espObjects[ball].connection:Disconnect() end
                espObjects[ball] = nil
            end
        end
    end)
end

local function updateESPVisibility()
    for _, data in pairs(espObjects) do
        if config.BallESPEnabled then
            data.gui.Enabled = true
        else
            data.gui.Enabled = false
        end
    end
end

-- ====== MAGNET ======
local function applyMagnet(ball)
    if not config.MagnetEnabled then return end
    if not ball or not ball:IsA("BasePart") then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local distance = (ball.Position - hrp.Position).Magnitude
    if distance > config.MagnetRange then return end

    local direction = (hrp.Position - ball.Position).Unit
    local force = math.clamp(config.MagnetStrength * 50, 0, 500)
    local currentY = ball.AssemblyLinearVelocity.Y * 0.3
    ball.AssemblyLinearVelocity = direction * force + Vector3.new(0, currentY, 0)
end

-- ====== PULL VECTOR ======
local function applyPullVector(ball)
    if not config.PullVectorEnabled then return end
    if not ball or not ball:IsA("BasePart") then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local toBall = ball.Position - hrp.Position
    local influence = toBall.Unit * config.PullVectorStrength * 0.1
    ball.AssemblyLinearVelocity = ball.AssemblyLinearVelocity + influence
end

-- ====== AUTO CATCH ======
local function tryAutoCatch()
    if not config.AutoCatch then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = LocalPlayer.Character.HumanoidRootPart
    for _, obj in pairs(Workspace:GetChildren()) do
        if obj.Name == config.MagnetTargetName and obj:IsA("BasePart") then
            local dist = (obj.Position - hrp.Position).Magnitude
            if dist <= config.MagnetRange then
                applyMagnet(obj)
            end
        end
    end
end

-- ====== AUTO RUSH ======
local function tryAutoRush()
    if not config.AutoRush then return end
    if tick() - lastRush < config.RushCooldown then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = LocalPlayer.Character.HumanoidRootPart
    for _, obj in pairs(Workspace:GetChildren()) do
        if obj.Name == "Football" and obj:IsA("BasePart") then
            local dist = (obj.Position - hrp.Position).Magnitude
            if dist <= config.RushDistance then
                local look = hrp.CFrame.LookVector
                hrp.Velocity = look * 60
                lastRush = tick()
                break
            end
        end
    end
end

-- ====== PREDICTION HANDLER ======
local function handleFootballPrediction(ball)
    if not ball or not ball:IsA("BasePart") then return end
    if predictionCache[ball] then return end
    predictionCache[ball] = true

    if not config.LandingPredictionEnabled then
        predictionCache[ball] = nil
        return
    end

    local velocity = ball.AssemblyLinearVelocity
    local points, landing = getTrajectory(ball.Position, velocity)
    local beams, atts = makeArc(points, config.PredictionColor)
    glowLoop(beams)
    ringMarker(landing, config.PredictionColor)
    if config.UseTrail then
        addTrail(ball)
    end

    local con
    con = RunService.Heartbeat:Connect(function()
        if not ball or not ball.Parent then
            fadeOutBeams(beams, 0.6)
            for _, a in ipairs(atts) do safeDestroy(a) end
            if con then con:Disconnect() end
            predictionCache[ball] = nil
            return
        end
        if ball.Velocity.Magnitude < 1 then
            if config.LandingPredictionEnabled then
                fadeOutBeams(beams, 0.8)
            else
                for _, b in ipairs(beams) do
                    b.Transparency = NumberSequence.new(1)
                end
            end
            for _, a in ipairs(atts) do safeDestroy(a) end
            if con then con:Disconnect() end
            predictionCache[ball] = nil
        end
    end)
end

-- ====== WORLD MONITOR ======
workspace.ChildAdded:Connect(function(child)
    if child.Name == "Football" and child:IsA("BasePart") then
        task.wait()
        if config.BallESPEnabled then createESP(child) end
        if config.LandingPredictionEnabled then handleFootballPrediction(child) end
    end
end)

for _, obj in pairs(Workspace:GetChildren()) do
    if obj.Name == "Football" and obj:IsA("BasePart") then
        if config.BallESPEnabled then createESP(obj) end
        if config.LandingPredictionEnabled then handleFootballPrediction(obj) end
    end
end

-- ====== MAIN LOOP ======
task.spawn(function()
    while true do
        tryAutoCatch()
        tryAutoRush()
        for _, obj in pairs(Workspace:GetChildren()) do
            if obj.Name == "Football" and obj:IsA("BasePart") then
                if config.MagnetEnabled then applyMagnet(obj) end
                if config.PullVectorEnabled then applyPullVector(obj) end
                if config.BallESPEnabled then createESP(obj) end
                if config.LandingPredictionEnabled then handleFootballPrediction(obj) end
            end
        end
        updateESPVisibility()
        task.wait(0.1)
    end
end)

-- ====== LUA HUB GUI (fallback or separate) ======
local function createToggle(parent, name, initial, callback)
    local container = Instance.new("Frame", parent)
    container.Size = UDim2.new(1, -14, 0, 26)
    container.BackgroundTransparency = 1

    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(0.6, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = name
    label.Font = Enum.Font.Code
    label.TextSize = 14
    label.TextColor3 = Color3.new(1,1,1)
    label.TextXAlignment = Enum.TextXAlignment.Left

    local btn = Instance.new("TextButton", container)
    btn.Size = UDim2.new(0.35, 0, 1, 0)
    btn.Position = UDim2.new(0.65, 0, 0, 0)
    btn.Text = initial and "ON" or "OFF"
    btn.Font = Enum.Font.Code
    btn.TextSize = 14
    btn.AutoButtonColor = false
    btn.BackgroundColor3 = initial and Color3.fromRGB(50,150,50) or Color3.fromRGB(120,50,50)
    btn.TextColor3 = Color3.new(1,1,1)
    local state = initial
    btn.MouseButton1Click:Connect(function()
        state = not state
        btn.Text = state and "ON" or "OFF"
        btn.BackgroundColor3 = state and Color3.fromRGB(50,150,50) or Color3.fromRGB(120,50,50)
        callback(state)
    end)
    return container
end

local function createSlider(parent, name, min, max, initial, callback)
    local container = Instance.new("Frame", parent)
    container.Size = UDim2.new(1, -14, 0, 36)
    container.BackgroundTransparency = 1

    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(1, 0, 0, 16)
    label.BackgroundTransparency = 1
    label.Text = name..": "..tostring(initial)
    label.Font = Enum.Font.Code
    label.TextSize = 13
    label.TextColor3 = Color3.new(1,1,1)
    label.TextXAlignment = Enum.TextXAlignment.Left

    local bar = Instance.new("Frame", container)
    bar.Size = UDim2.new(1, 0, 0, 16)
    bar.Position = UDim2.new(0,0,0,18)
    bar.BackgroundColor3 = Color3.fromRGB(45,45,45)
    bar.BorderSizePixel = 0

    local fill = Instance.new("Frame", bar)
    fill.Size = UDim2.new((initial - min)/(max - min), 0, 1, 0)
    fill.BackgroundColor3 = Color3.fromRGB(100,100,100)
    fill.BorderSizePixel = 0

    local dragging = false
    bar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true end
    end)
    bar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    bar.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local absX = input.Position.X - bar.AbsolutePosition.X
            local frac = math.clamp(absX / bar.AbsoluteSize.X, 0, 1)
            fill.Size = UDim2.new(frac, 0, 1, 0)
            local value = min + (max - min)*frac
            label.Text = name..": "..string.format("%.2f", value)
            callback(value)
        end
    end)
    return container
end

local function buildLuaHub()
    local existing = PlayerGui:FindFirstChild("FF2_LuaHub")
    if existing then safeDestroy(existing) end

    local gui = Instance.new("ScreenGui")
    gui.Name = "FF2_LuaHub"
    gui.ResetOnSpawn = false
    gui.Parent = PlayerGui

    local main = Instance.new("Frame")
    main.Size = UDim2.new(0, 340, 0, 500)
    main.Position = UDim2.new(0.3, 0, 0.2, 0)
    main.BackgroundColor3 = Color3.fromRGB(30,30,30)
    main.BorderSizePixel = 0
    main.Parent = gui
    main.Name = "HubFrame"
    main.ClipsDescendants = true

    -- draggable
    do
        local dragging, dragStart, startPos
        main.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = main.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then dragging = false end
                end)
            end
        end)
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end)
    end

    local title = Instance.new("TextLabel", main)
    title.Size = UDim2.new(1, 0, 0, 28)
    title.Position = UDim2.new(0,0,0,0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.TextSize = 18
    title.Text = "FF2 Hub"
    title.TextColor3 = Color3.new(1,1,1)
    title.TextXAlignment = Enum.TextXAlignment.Left

    local container = Instance.new("Frame", main)
    container.Size = UDim2.new(1, -12, 1, -36)
    container.Position = UDim2.new(0,6,0,32)
    container.BackgroundTransparency = 1

    local y = 0
    local function add(child)
        child.Position = UDim2.new(0, 8, 0, y)
        child.Parent = container
        y = y + child.Size.Y.Offset + 6
    end

    add(createToggle(container, "Magnet", config.MagnetEnabled, function(v) config.MagnetEnabled = v end))
    add(createSlider(container, "Magnet Range", 1, 100, config.MagnetRange, function(v) config.MagnetRange = v end))
    add(createSlider(container, "Magnet Strength", 0.1, 5, config.MagnetStrength, function(v) config.MagnetStrength = v end))

    add(createToggle(container, "Pull Vector", config.PullVectorEnabled, function(v) config.PullVectorEnabled = v end))
    add(createSlider(container, "Pull Vector Strength", 0, 80, config.PullVectorStrength, function(v) config.PullVectorStrength = v end))

    add(createToggle(container, "Ball ESP", config.BallESPEnabled, function(v) config.BallESPEnabled = v end))
    add(createToggle(container, "Landing Prediction", config.LandingPredictionEnabled, function(v) config.LandingPredictionEnabled = v end))
    add(createToggle(container, "Trail", config.UseTrail, function(v) config.UseTrail = v end))

    add(createToggle(container, "Auto Catch", config.AutoCatch, function(v) config.AutoCatch = v end))
    add(createToggle(container, "Auto Rush", config.AutoRush, function(v) config.AutoRush = v end))
    add(createSlider(container, "Rush Distance", 5, 100, config.RushDistance, function(v) config.RushDistance = v end))
    add(createSlider(container, "Rush Cooldown", 0.2, 3, config.RushCooldown, function(v) config.RushCooldown = v end))
end

-- build fallback hub immediately
buildLuaHub()

-- ====== RAYFIELD GUI LOADER (separate) ======
-- Attempt to load Rayfield; if you have your own Rayfield loader replace the URL accordingly.
local successRay, Rayfield = pcall(function()
    -- Example public Rayfield loader; if blocked, swap with your locally stored Rayfield code
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/LucidXPro/Rayfield/main/source"))()
end)

if successRay and Rayfield then
    local window = Rayfield:CreateWindow({
        Name = "FF2 Hub",
        LoadingTitle = "Football Fusion 2",
        HidePremium = true,
        ConfigurationSaving = {
            Enabled = false
        },
    })

    local mainTab = window:CreateTab("Main", nil)
    local visualsTab = window:CreateTab("Visuals", nil)
    local miscTab = window:CreateTab("Misc", nil)

    -- Magnet group
    local magnetSection = mainTab:CreateSection("Magnet")
    mainTab:CreateToggle({
        Name = "Enable Magnet",
        CurrentValue = config.MagnetEnabled,
        Flag = "MagnetEnabled",
        Callback = function(v) config.MagnetEnabled = v end,
    })
    mainTab:CreateSlider({
        Name = "Magnet Range",
        Range = {1, 100},
        Increment = 1,
        Suffix = "",
        CurrentValue = config.MagnetRange,
        Flag = "MagnetRange",
        Callback = function(v) config.MagnetRange = v end,
    })
    mainTab:CreateSlider({
        Name = "Magnet Strength",
        Range = {0.1, 5},
        Increment = 0.1,
        Suffix = "",
        CurrentValue = config.MagnetStrength,
        Flag = "MagnetStrength",
        Callback = function(v) config.MagnetStrength = v end,
    })

    -- Pull vector
    mainTab:CreateToggle({
        Name = "Pull V
